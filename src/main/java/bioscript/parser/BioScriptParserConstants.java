/* Generated By:JavaCC: Do not edit this line. bioscript.parser.ParseException.BioScriptParserConstants.java */
package bioscript.parser;


/**
 * bioscript.parser.Token literal values and constants. Generated by
 * org.javacc.parser.OtherFilesGen#start()
 */
public interface BioScriptParserConstants {

    /**
     * End of File.
     */
    int EOF = 0;
    /**
     * RegularExpression Id.
     */
    int MIX = 6;
    /**
     * RegularExpression Id.
     */
    int SPLIT = 7;
    /**
     * RegularExpression Id.
     */
    int DRAIN = 8;
    /**
     * RegularExpression Id.
     */
    int HEAT = 9;
    /**
     * RegularExpression Id.
     */
    int FOR = 10;
    /**
     * RegularExpression Id.
     */
    int AT = 11;
    /**
     * RegularExpression Id.
     */
    int DETECT = 12;
    /**
     * RegularExpression Id.
     */
    int REPEAT = 13;
    /**
     * RegularExpression Id.
     */
    int IF = 14;
    /**
     * RegularExpression Id.
     */
    int ELSE = 15;
    /**
     * RegularExpression Id.
     */
    int IDENTIFIER = 16;
    /**
     * RegularExpression Id.
     */
    int INT_SCALAR = 17;
    /**
     * RegularExpression Id.
     */
    int LETTER = 18;
    /**
     * RegularExpression Id.
     */
    int DIGIT = 19;
    /**
     * RegularExpression Id.
     */
    int LPAREN = 20;
    /**
     * RegularExpression Id.
     */
    int RPAREN = 21;
    /**
     * RegularExpression Id.
     */
    int LBRACKET = 22;
    /**
     * RegularExpression Id.
     */
    int RBRACKET = 23;
    /**
     * RegularExpression Id.
     */
    int LBRACE = 24;
    /**
     * RegularExpression Id.
     */
    int RBRACE = 25;
    /**
     * RegularExpression Id.
     */
    int DOT = 26;
    /**
     * RegularExpression Id.
     */
    int ADD = 27;
    /**
     * RegularExpression Id.
     */
    int AND = 28;
    /**
     * RegularExpression Id.
     */
    int ASSIGN = 29;
    /**
     * RegularExpression Id.
     */
    int BANG = 30;
    /**
     * RegularExpression Id.
     */
    int LESSTHAN = 31;
    /**
     * RegularExpression Id.
     */
    int GREATERTHAN = 32;
    /**
     * RegularExpression Id.
     */
    int MINUS = 33;
    /**
     * RegularExpression Id.
     */
    int OR = 34;

    /**
     * Lexical state.
     */
    int DEFAULT = 0;

    /**
     * Literal token values.
     */
    String[] tokenImage = {
            "<EOF>",
            "\" \"",
            "\"\\t\"",
            "\"\\n\"",
            "\"\\r\"",
            "\"\\f\"",
            "\"mix\"",
            "\"split\"",
            "\"drain\"",
            "\"heat\"",
            "\"for\"",
            "\"at\"",
            "\"detect\"",
            "\"repeat\"",
            "\"if\"",
            "\"else\"",
            "<IDENTIFIER>",
            "<INT_SCALAR>",
            "<LETTER>",
            "<DIGIT>",
            "\"(\"",
            "\")\"",
            "\"[\"",
            "\"]\"",
            "\"{\"",
            "\"}\"",
            "\".\"",
            "\"+\"",
            "\"&&\"",
            "\"=\"",
            "\"!\"",
            "\"<\"",
            "\">\"",
            "\"-\"",
            "\"||\"",
    };

    class BioScriptParser implements BioScriptParserConstants {

        /**
         * Generated bioscript.parser.Token Manager.
         */
        public BioScriptParserTokenManager token_source;
        JavaCharStream jj_input_stream;
        /**
         * Current token.
         */
        public Token token;
        /**
         * Next token.
         */
        public Token jj_nt;
        private int jj_ntk;
        private int jj_gen;
        final private int[] jj_la1 = new int[0];
        static private int[] jj_la1_0;
        static private int[] jj_la1_1;

        static {
            jj_la1_init_0();
            jj_la1_init_1();
        }

        private static void jj_la1_init_0() {
            jj_la1_0 = new int[]{};
        }

        private static void jj_la1_init_1() {
            jj_la1_1 = new int[]{};
        }

        /**
         * Constructor with InputStream.
         */
        public BioScriptParser(java.io.InputStream stream) {
            this(stream, null);
        }

        /**
         * Constructor with InputStream and supplied encoding
         */
        public BioScriptParser(java.io.InputStream stream, String encoding) {
            try {
                jj_input_stream = new JavaCharStream(stream, encoding, 1, 1);
            } catch (java.io.UnsupportedEncodingException e) {
                throw new RuntimeException(e);
            }
            token_source = new BioScriptParserTokenManager(jj_input_stream);
            token = new Token();
            jj_ntk = -1;
            jj_gen = 0;
        }

        /**
         * Reinitialise.
         */
        public void ReInit(java.io.InputStream stream) {
            ReInit(stream, null);
        }

        /**
         * Reinitialise.
         */
        public void ReInit(java.io.InputStream stream, String encoding) {
            try {
                jj_input_stream.ReInit(stream, encoding, 1, 1);
            } catch (java.io.UnsupportedEncodingException e) {
                throw new RuntimeException(e);
            }
            token_source.ReInit(jj_input_stream);
            token = new Token();
            jj_ntk = -1;
            jj_gen = 0;
            for (int i = 0; i < 0; i++) jj_la1[i] = -1;
        }

        /**
         * Constructor.
         */
        public BioScriptParser(java.io.Reader stream) {
            jj_input_stream = new JavaCharStream(stream, 1, 1);
            token_source = new BioScriptParserTokenManager(jj_input_stream);
            token = new Token();
            jj_ntk = -1;
            jj_gen = 0;
        }

        /**
         * Reinitialise.
         */
        public void ReInit(java.io.Reader stream) {
            jj_input_stream.ReInit(stream, 1, 1);
            token_source.ReInit(jj_input_stream);
            token = new Token();
            jj_ntk = -1;
            jj_gen = 0;
        }

        /**
         * Constructor with generated bioscript.parser.Token Manager.
         */
        public BioScriptParser(BioScriptParserTokenManager tm) {
            token_source = tm;
            token = new Token();
            jj_ntk = -1;
            jj_gen = 0;
        }

        /**
         * Reinitialise.
         */
        public void ReInit(BioScriptParserTokenManager tm) {
            token_source = tm;
            token = new Token();
            jj_ntk = -1;
            jj_gen = 0;
        }

        private Token jj_consume_token(int kind) throws ParseException {
            Token oldToken;
            if ((oldToken = token).next != null) token = token.next;
            else token = token.next = token_source.getNextToken();
            jj_ntk = -1;
            if (token.kind == kind) {
                jj_gen++;
                trace_token(token, "");
                return token;
            }
            token = oldToken;
            jj_kind = kind;
            throw generateParseException();
        }


        /**
         * Get the next bioscript.parser.Token.
         */
        final public Token getNextToken() {
            if (token.next != null) token = token.next;
            else token = token.next = token_source.getNextToken();
            jj_ntk = -1;
            jj_gen++;
            trace_token(token, " (in getNextToken)");
            return token;
        }

        /**
         * Get the specific bioscript.parser.Token.
         */
        final public Token getToken(int index) {
            Token t = token;
            for (int i = 0; i < index; i++) {
                if (t.next != null) t = t.next;
                else t = t.next = token_source.getNextToken();
            }
            return t;
        }

        private int jj_ntk_f() {
            if ((jj_nt = token.next) == null)
                return (jj_ntk = (token.next = token_source.getNextToken()).kind);
            else
                return (jj_ntk = jj_nt.kind);
        }

        private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
        private int[] jj_expentry;
        private int jj_kind = -1;

        /**
         * Generate bioscript.parser.ParseException.
         */
        public ParseException generateParseException() {
            jj_expentries.clear();
            boolean[] la1tokens = new boolean[35];
            if (jj_kind >= 0) {
                la1tokens[jj_kind] = true;
                jj_kind = -1;
            }
            for (int i = 0; i < 0; i++) {
                if (jj_la1[i] == jj_gen) {
                    for (int j = 0; j < 32; j++) {
                        if ((jj_la1_0[i] & (1 << j)) != 0) {
                            la1tokens[j] = true;
                        }
                        if ((jj_la1_1[i] & (1 << j)) != 0) {
                            la1tokens[32 + j] = true;
                        }
                    }
                }
            }
            for (int i = 0; i < 35; i++) {
                if (la1tokens[i]) {
                    jj_expentry = new int[1];
                    jj_expentry[0] = i;
                    jj_expentries.add(jj_expentry);
                }
            }
            int[][] exptokseq = new int[jj_expentries.size()][];
            for (int i = 0; i < jj_expentries.size(); i++) {
                exptokseq[i] = jj_expentries.get(i);
            }
            return new ParseException(token, exptokseq, BioScriptParserConstants.tokenImage);
        }

        private int trace_indent = 0;
        private boolean trace_enabled = true;

        /**
         * Enable tracing.
         */
        final public void enable_tracing() {
            trace_enabled = true;
        }

        /**
         * Disable tracing.
         */
        final public void disable_tracing() {
            trace_enabled = false;
        }

        private void trace_call(String s) {
            if (trace_enabled) {
                for (int i = 0; i < trace_indent; i++) {
                    System.out.print(" ");
                }
                System.out.println("Call:   " + s);
            }
            trace_indent = trace_indent + 2;
        }

        private void trace_return(String s) {
            trace_indent = trace_indent - 2;
            if (trace_enabled) {
                for (int i = 0; i < trace_indent; i++) {
                    System.out.print(" ");
                }
                System.out.println("Return: " + s);
            }
        }

        private void trace_token(Token t, String where) {
            if (trace_enabled) {
                for (int i = 0; i < trace_indent; i++) {
                    System.out.print(" ");
                }
                System.out.print("Consumed token: <" + BioScriptParserConstants.tokenImage[t.kind]);
                if (t.kind != 0 && !BioScriptParserConstants.tokenImage[t.kind].equals("\"" + t.image + "\"")) {
                    System.out.print(": \"" + t.image + "\"");
                }
                System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
            }
        }

        private void trace_scan(Token t1, int t2) {
            if (trace_enabled) {
                for (int i = 0; i < trace_indent; i++) {
                    System.out.print(" ");
                }
                System.out.print("Visited token: <" + BioScriptParserConstants.tokenImage[t1.kind]);
                if (t1.kind != 0 && !BioScriptParserConstants.tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
                    System.out.print(": \"" + t1.image + "\"");
                }
                System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + BioScriptParserConstants.tokenImage[t2] + ">");
            }
        }

    }
}
