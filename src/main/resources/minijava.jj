/*
The grammar file definition:
    https://javacc.org/javaccgrm
*/

options {
    STATIC = false;
    DEBUG_PARSER = true;
    DEBUG_LOOKAHEAD = true;
    DEBUG_TOKEN_MANAGER = true;
    ERROR_REPORTING = true;
    JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MJParser)

import java.util.ArrayList;

public class MJParser {}

PARSER_END(MJParser)

/* WHITE SPACE */

SKIP:
{
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
    <BOOLEAN: "boolean">
|   <BREAK: "break">
|   <CLASS: "class">
|   <CONTINUE: "continue">
|   <DO: "do">
|   <ELSE: "else">
|   <EXTENDS: "extends">
|   <FALSE: "false">
|   <FOR: "for">
|   <IF: "if">
|   <INT: "int">
|   <MAIN: "main">
|   <NEW: "new">
|   <PRIVATE: "private">
|   <PROTECTED: "protected">
|   <PRINT: "print">
|   <PUBLIC: "public">
|   <RETURN: "return">
|   <STATIC: "static">
|   <STRING: "String">
|   <SUPER: "super">
|   <THIS: "this">
|   <TRUE: "true">
|   <VOID: "void">
|   <WHILE: "while">
|   <DOTLENGTH: ".length">
}

/* IDENTIFIERS */

TOKEN :
{
    <IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"_")*>
|   <INT_SCALAR: "0" | (["1"-"9"](<DIGIT>)*)>
|   <LETTER: ["a"-"z"] | ["A"-"Z"]>
|   <DIGIT: ["0"-"9"]>
}

/* LOGIC, SCOPING, ARRAYS, AND OPERATORS */
TOKEN : {
    <LPAREN: "(">
|   <RPAREN: ")">
|   <LBRACKET: "[">
|   <RBRACKET: "]">
|   <LBRACE: "{">
|   <RBRACE: "}">
|   <ADD: "+">
|   <AND: "&&">
|   <ASSIGN: "=">
|   <BANG: "!">
|   <COMMA: ",">
|   <DOT: ".">
|   <LESSTHAN: "<">
|   <GREATERTHAN: ">">
|   <MINUS: "-">
|   <MULTIPLY: "*">
|   <DIVIDE: "/">
|   <SEMICOLON: ";">
|   <OR: "||">
}

Program Program() : {
    MainClass mainClass;
    ClassDeclaration currentClass;
    List<ClassDeclaration> classes = new ArrayList<ClassDeclaration>();
} {
    mainClass = MainClass() (
        currentClass = ClassDeclaration()
        { classes.add(currentClass); }
    )* <EOF>
    { return new Program(mainClass, new NodeList<ClassDeclaration>(classes)); }
}

MainClass MainClass() : {
    Token className;
    Token argName;
    Statement statement;
} {
    <CLASS> (className = <IDENTIFIER>) <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN>
            <LPAREN> <STRING> <LBRACKET> <RBRACKET> (argName = <IDENTIFIER>) <RPAREN>
            <LBRACE>
                (statement = Statement())
            <RBRACE>
        <RBRACE>

        { return new MainClass(className.image, argName.image, statement); }
}

ClassDeclaration ClassDeclaration() : {
    Token id;
    Token extending = null;
    List<VarDeclaration> variables = new ArrayList<VariableDeclaration>();
    List<MethodDeclaration> methods = new ArrayList<MethodDeclaration>();
} {
    <CLASS> id=<IDENTIFIER> ( <EXTENDS> (extending = <IDENTIFIER>) ) ? <LBRACE>
        ( ( { VariablDeclaration variable = null; } variable = VariableDeclaration(VariableDeclaration.Kind.FIELD) {variables.add(variable); })
        | ({ MethodDeclaration method = null; } method = MethodDeclaration() {methods.add(method); }) ) *
    <RBRACE>
    {return new ClassDeclaration(id.image, (exts!=null?exts.image:null), variables, methods);}
}

VariableDeclaration VariableDeclaration(VariableDeclaration.Kind kind) : {
    Type type;
    Token name;
} {
    type = Type() name = <IDENTIFIER> <SEMICOLON>
    {return new VariableDeclaration(kind, t, name.image); }
}

MethodDeclaration MethodDeclaration() : {
    Type returnType;
    Token name;
    NodeList<VariableDeclaration> args;
    List<Statement> body = new ArrayList<Statement>();
    List<VariableDeclaration> variables = new ArrayList<VariableDeclaration>();
} {

    (<PUBLIC> | <PRIVATE> | <PROTECTED>) type = Type() name = <IDENTIFIER> <LPAREN> args = FormalList() <RPAREN> <LBRACE>
    (LOOKAHEAD(2)
        ({VariableDeclaration var;} var = VariableDeclaration(VariableDeclaration.Kind.LOCAL) {variables.add(var);})
        | ( {Statement statement;} statement = Statement() {body.add(statement);})
    )*
    <RETURN> {Expression returnStatement;} (returnStatement = Expression()) <SEMICOLON>
    <RBRACE>

    {return new MethodDeclaration(returnType, name, args,
        new NodeList<VariableDeclaration>(vars), new NodeList(body), returnStatement); }
}

NodeList<VariableDeclaration> FormalList() : {
	Type type;
	Token name;
	ArrayList<VariableDeclaration> vars = new ArrayList<VariableDeclaration>();
} {
    (
    	type = Type() name = <IDENTIFIER>
    	{ vars.add(new VariableDeclaration(VariableDeclaration.Kind.FORMAL, type, name.image)); }
     	(
     		<COMMA> type = Type() name = <IDENTIFIER>
     		{ vars.add(new VariableDeclaration(VariableDeclaration.Kind.FORMAL, type, name.image)); }
     	)*
    )?
    { return new NodeList<VariableDeclaration>(vars); }
}

Type Type() : { }
{
    ( <INT> (<LBRACKET><RBRACKET> {return IntArrayType.instance;})? {return IntegerType.instance;} )
|   ( <BOOLEAN> {return BooleanType.instance;})
|   ( <STRING> {return new ObjectType("String");})
|   ( {Token name; } name = <IDENTIFIER> { return new ObjectType(name.image);} )
}

Statement Statement() : {
    Statement statement;
    Statement statementLocal;
    Expression expression;
    Expression branch;
} {
    (
        {List<Statement> statements = new ArrayList<Statements>();}
        <LBRACE> ((statementLocal = Statement()) {statements.add(statementLocal);})* <RBRACE>
        { return new Block(new NodeList<Statement>(statements));}
    )
|   (
        {Statement conditionTrue; Statement conditionFalse; List<Statement> elseIfConditions = new ArrayList<Statement>();}
        <IF> <LPAREN> (test = Expression()) <RPAREN> <LBRACE>
            (conditionTrue = Statement())
        <RBRACE>
        <ELSE> <LBRACE>
            (conditionFalse = Statement())
        <RBRACE>

        {return new Branch(test, conditionTrue, conditionFalse);}
    )
|   (
        {Statement body;}
        <WHILE> <LPAREN> (test = Expression()) <RPAREN> <LBRACE>
            (body = Statement())
        <RBRACE>
        {return new While(test, body); }
    )
|   (
        {Statement body;}
        <DO> <LBRACE>
            (body = Statement())
        <RBRACE> <WHILE> <LPAREN> (test = Expression()) <RPAREN> <SEMICOLON>
        {return new DoWhile(test, body); }
    )
|   (
        <PRINT> <LPAREN>(expression = Expression()) <RPAREN> <SEMICOLON>
        {return new Print(expression);}
    )
|   (
        {Token name; Expression index = null; Expression assign; }
        (name = <IDENTIFIER>)(<LBRACKET>(index = Expression()) <RBRACKET>) ? <ASSIGN> (assign = Expression()) <SEMICOLON>
        {
            if (index == null) {
                return new Assign(name.image, assign);
            } else {
                return new ArrayAssign(id.image, index, assign);
            }
        }
    )
}


Expression Expression() : {
    Expression left, right;
} {
    left = LessThanTerm() (
        LOOKAHEAD(2)
        <AND> right = LessThanTerm()
        { left = new And(left, right); }
    )*
    {return left;}
}

Expression LessThanTerm() : {
    Expression left, right;
} {
    left = GreaterThanTerm() (
        LOOKAHEAD(2)
        <LESSTHAN> right = GreaterThanTerm()
        { left = new LessThanTerm(left, right); }
    )*
    {return left;}
}

Expression GreaterThanTerm() : {
    Expression left, right;
} {
    left = AdditionTerm() (
        LOOKAHEAD(2)
        <GREATERTHAN> right = AdditionTerm()
        {left = new GreaterThanTerm(left, right); }
    )*
    {return left;}
}

Expression AdditionTerm() : {
    Expression left, right;
} {
    left = DivideTerm() (
        LOOKAHEAD(2)
        <ADD> right = DivideTerm()
        {left = new Addition(left, right);}
        | <MINUS> right = DivideTerm()
        {left = new Subtraction(left, right);}
    )*
    {return left;}
}

Expression DivideTerm() : {
    Expression left, right;
} {
    left = MultiplyTerm() (
        LOOKAHEAD(2)
        <DIVIDE> right = MultiplyTerm()
        {left = new Division(left, right);}
    )*
    {return left;}
}

Expression MultiplyTerm() : {
    Expression left, right;
} {
    left = NotTerm() (
        LOOKAHEAD(2)
        <MULTIPLY> right = NotTerm()
        {left = new Multiplication(left, right);}
    )*
    {return left;}
}

Expression NotTerm() : {
    Expression expression;
} {
    LOOKAHEAD(2)
    ( <BANG> expression = NotTerm() { return new Negation(expression);} )
    | ( expression = DotTerm() {return expression;} )
}

Expression DotTerm() : {
    Expression left, right;
} {
    left = ArrayTerm()
    (
        (<DOTLENGTH>{return new ArrayLength(left);})
        | (<DOT> left = MethodInvoke(left) {left = right;})
    )*
    {return left;}
}

Expression MethodInvoke(Expression left) : {
    Expression arg;
    List<Expression> args = new ArrayList<Expression>();
} {
    (
        { Token name; }
        name = <IDENTIFIER>
        <LPAREN>
        (
            (arg = Expression() {args.add(arg);})
            (<COMMA> (arg = Expression() {args.add(arg);}))*
        )
        <RPAREN>
        {return new Invoke(left, name.image, new NodeList<Expression>(args));}
    )
}

Expression ArrayTerm() : { } {
    {
        Expression term;
        Expression index = null;
    }
    (
        LOOKAHEAD(1)
        <LBRACKET> index = Expression() <RBRACKET>
    )?
    {
        if (index == null) {
            return term;
        } else {
            return new ArrayLookUp(term, index);
        }
    }
}

Expression TerminalExpression() : {
    Token name;
    Expression term;
} {
    name = <INT_SCALAR>
    {return new IntegerLiteral(String.valueOf(name.image));}

    | name = <IDENTIFIER>
    {return new IdentifierExpression(id.image);}

    | <NEW> term = InstantiateObject()
    {return term;}

    | <LPAREN> term = Expression() <RPAREN>
    { return term; }

    | <THIS>
    {return new Instance();}

    | <TRUE>
    { return new BooleanLiteral(true); }

    | <FALSE>
    { return new BooleanLiteral(false); }
}

Expression InstantiateObject() : { }
{
    (
     	{ Expression expression; }
        <INT> <LBRACKET> (expression = Expression()) <RBRACKET>
        { return new NewArray(exp); }
    )

    | (
        {Token name;}
        name = <IDENTIFIER> <LPAREN> <RPAREN>
        {return new NewObject(name.image);}
    )
}